#+begin_src latex
  \section*{Introduction}
  The program \ty{ego} tests for enrichment of GO terms in a sample of
  genes. It does so by reading a list of observed gene IDs
  (Table~\ref{tab:eg}) and multiple ID lists that together represent the
  null distribution of random ID picks. These random lists can be
  generated by the program \ty{shuffle}. \ty{ego} then calculates the
  frequency with which each GO category occupied by at least, say, ten
  genes has at least an equal occupancy in the expected lists. This
  frequency is the $P$-value for enrichment of that category, that is,
  the error probability when rejecting the null hypothesis that the
  observed occupancy is due to chance. Mapping the gene IDs onto GO IDs
  is done using the file \ty{gene2go} available from
  \begin{verbatim}
  ftp://ftp.ncbi.nih.gov/gene/DATA/gene2go.gz
  \end{verbatim}

  \begin{table}
    \caption{A list of observed gene IDs (\textbf{A}) is transformed
      by \ty{ego} into a list of GO-IDs and their enrichment
      (\textbf{B}).}\label{tab:eg}
    \begin{center}
      \begin{tabular}{cc}
	\textbf{A} & \textbf{B}\\
	\input{../ego/egoTab1} & \input{../ego/egoTab2}
      \end{tabular}
    \end{center}
  \end{table}

  As an auxiliary functionality, \ty{ego} can also classify the input
  IDs into their GO categories, map the IDs onto their gene symbols, and
  print what I call a GO/sym table, for example
  Table~\ref{tab:eg2}. This requires the genome's annotations in the GFF
  format distributed by the NCBI.

  \begin{table}
    \caption{Example GO/sym table.}\label{tab:eg2}
    \begin{center}
      \resizebox{\textwidth}{!}{
	\begin{tabular}{cclll}
	\hline
	GO & Count & Category & Description & Sym\\\hline
	\input{../ego/egoTab3}\\
	\hline
	\end{tabular}
      }
    \end{center}
  \end{table}

  \section*{Implementation}
  The outline of \ty{ego} contains hooks for imports, types, methods,
  functions, and the logic of the main function.
#+end_src
#+begin_src go <<ego.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:eg}>>
  )
  //<<Types, Ch.~\ref{ch:eg}>>
  //<<Methods, Ch.~\ref{ch:eg}>>
  //<<Functions, Ch.~\ref{ch:eg}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  In the main function, we set the program name and its usage, declare
  the options, parse the options, and parse the input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:eg}>>=
  util.Name("ego")
  //<<Set usage, Ch.~\ref{ch:eg}>>
  //<<Declare options, Ch.~\ref{ch:eg}>>
  //<<Parse options, Ch.~\ref{ch:eg}>>
  //<<Parse input files, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "github.com/evolbioinf/gin/util"
#+end_src
#+begin_src latex
  The usage consists of the actual usage message, an explanation of the
  purpose of \ty{ego}, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:eg}>>=
  u := "ego [-h] -o gene2go [option]... " +
	  "obsID.txt [expID.txt]..."
  p := "Calculate enrichment of GO terms for " +
	  "observed list of gene IDs, given a "+
	  "large number of expected ID lists."
  e := "ego -o gene2go obsID.txt expID.txt"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  Apart from the version, \ty{-v}, we declare four options, the file
  containing the GO terms, \ty{-o}, the GFF file for printing the GO/sym
  table, \ty{-g}, and the minimum occupancy of a GO term to be included
  in the final result, \ty{-m}.
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:eg}>>=
  var optV = flag.Bool("v", false, "version")
  var optO = flag.String("o", "", "file of mapping " +
	  "gene IDs to GO terms")
  var optG = flag.String("g", "",
	  "GFF file to print GO/sym table")
  var optM = flag.Int("m", 10, "minimum occupancy of GO term")
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "flag"
#+end_src
#+begin_src latex
  We parse the options and respond to \ty{-v} as this stops the
  program. We also check there is a file mapping gene IDs onto GO terms
  and bail with a friendly message if no such GO file exists. Then we
  read the GO file. We also declare a map of gene ID to gene symbol and
  fill it if there is a GFF file.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:eg}>>=
  flag.Parse()
  if *optV { util.Version() }
  if *optO == "" {
	  m := "please enter a file mapping gene IDs " +
		  "to GO accessions using -o"
	  log.Fatal(m)
  }
  //<<Read GO file, Ch.~\ref{ch:eg}>>
  var id2sym map[string]string
  if *optG != "" {
	  //<<Fill \ty{id2sym}, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  We import \ty{log}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "log"
#+end_src
#+begin_src latex
  To read the GO file, we open and scan it.
#+end_src
#+begin_src go <<Read GO file, Ch.~\ref{ch:eg}>>=
  f := util.Open(*optO)
  defer f.Close()
  sc := bufio.NewScanner(f)
  //<<Scan GO file, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_export latex
We import \ty{bufio}.
#+end_export
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "bufio"
#+end_src
#+begin_src latex
  During the scan, we extract the required GO attributes from the GO
  file. Then we store the GO ID as a function of the gene ID. Since a
  gene ID typically maps to many GO IDs, we store the relationship
  between a gene ID and a GO ID as a map between one gene ID and a map
  of GO IDs. We also store the GO description and the GO category as
  functions of the GO ID.
#+end_src
#+begin_src go <<Scan GO file, Ch.~\ref{ch:eg}>>=
  id2go := make(map[string]map[string]bool)
  go2descr := make(map[string]string)
  go2cat := make(map[string]string)
  for sc.Scan() {
	  if sc.Text()[0] == '#' { continue }
	  //<<Extract GO attributes, Ch.~\ref{ch:eg}>>
	  //<<Store GO ID, Ch.~\ref{ch:eg}>>
	  //<<Store GO description, Ch.~\ref{ch:eg}>>
	  //<<Store GO category, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  We check the GO file has eight columns and bail otherwise.  The gene
  ID is in column 2, the GO ID in column 3, the description of the GO
  term in column 6, and its category in column 8.
#+end_src
#+begin_src go <<Extract GO attributes, Ch.~\ref{ch:eg}>>=
  fields := strings.Split(sc.Text(), "\t")
  if len(fields) != 8 {
	  m := "gene2go file has %d columns instead of " +
		  "the expected 8; are you using " +
		  "the correct file?"
	  log.Fatalf(m, len(fields))
  }
  geneId := fields[1]
  goId := fields[2]
  goDescr := fields[5]
  goCat := fields[7]
#+end_src
#+begin_export latex
We import \ty{strings}.
#+end_export
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "strings"
#+end_src
#+begin_src latex
  We check whether a given gene ID already has an associated map of GO
  IDs. If not, we make it. Then we store the GO ID.
#+end_src
#+begin_src go <<Store GO ID, Ch.~\ref{ch:eg}>>=
  if id2go[geneId] == nil {
	  id2go[geneId] = make(map[string]bool)
  }
  id2go[geneId][goId] = true
#+end_src
#+begin_src latex
  GO descriptions may end with a GO ID in square brackets, which is
  redundant, so we cut it off with the preceding blank before storing
  the description. We also make sure the remaining description doesn't
  end in a blank.
#+end_src
#+begin_src go <<Store GO description, Ch.~\ref{ch:eg}>>=
  li := strings.LastIndex(goDescr, "[")
  if li > -1 && strings.Contains(goDescr, "GO:") {
	  if li > 0 {
		  goDescr = goDescr[:li-1]
	  } else {
		  goDescr = goDescr[:li]
	  }
  }
  go2descr[goId] = goDescr
#+end_src
#+begin_src latex
  We store the GO category.
#+end_src
#+begin_src go <<Store GO category, Ch.~\ref{ch:eg}>>=
  go2cat[goId] = goCat
#+end_src
#+begin_export latex
To fill our map between gene IDs and gene symbols, we allocate it and
scan the GFF file supplied by the user. We skip comments, check the
number of columns, and concentrate on genes, for which we store the
symbol.
#+end_export
#+begin_src go <<Fill \ty{id2sym}, Ch.~\ref{ch:eg}>>=
  id2sym = make(map[string]string)
  f := util.Open(*optG)
  sc := bufio.NewScanner(f)
  for sc.Scan() {
	  t := sc.Text()
	  if t[0] == '#' { continue }
	  fields := strings.Split(t, "\t")
	  //<<Check number of fields, Ch.~\ref{ch:eg}>>
	  if fields[2] == "gene" {
		  //<<Store gene symbol, Ch.~\ref{ch:eg}>>
	  }
  }
#+end_src
#+begin_export latex
There should be nine fields and we bail if we find something else.
#+end_export
#+begin_src go <<Check number of fields, Ch.~\ref{ch:eg}>>=
  if len(fields) != 9 {
	  m := "expecting 9 fields in GFF file, " +
		  "but you have %d"
	  log.Fatalf(m, len(fields))
  }
#+end_src
#+begin_export latex
We extract the gene ID and the gene symbol from the attribute string,
which is the nine-th column. The attribute string consists of a set of
key/value pairs, here is the example from the Introduction to
\ty{annotate}:
\begin{center}
ID=gene-HOXA1;Dbxref=GeneID:3198,...;Name=HOXA1;...
\end{center}
So we split the attribute string at the semicolon into its constituent
attributes and iterate over them. We split each attribute into its
key/value pair and search for the gene ID and the corresponding
symbol. We also check the results of our searches.
#+end_export
#+begin_src go <<Store gene symbol, Ch.~\ref{ch:eg}>>=
  sym := ""
  gid := ""
  attributes := strings.Split(fields[8], ";")
  for _, attribute := range attributes {
	  kv := strings.Split(attribute, "=")
	  //<<Search for gene ID, Ch.~\ref{ch:eg}>>
	  //<<Search for gene symbol, Ch.~\ref{ch:eg}>>
  }
  //<<Check gene ID, Ch.~\ref{ch:eg}>>
  //<<Check gene symbol, Ch.~\ref{ch:eg}>>
  id2sym[gid] = sym
#+end_src
#+begin_export latex
The gene ID is one of the key/value pairs stored under the key
``Dbxref''. These secondary key/value pairs are separated by commas
and a key is separated from a value by a colon. We look for key
``GeneID''.
#+end_export
#+begin_src go <<Search for gene ID, Ch.~\ref{ch:eg}>>=
  if kv[0] == "Dbxref" {
	  ids := strings.Split(kv[1], ",")
	  for _, id := range ids {
		  arr := strings.Split(id, ":")
		  if arr[0] == "GeneID" {
			  gid = arr[1]
		  }
	  }
  }
#+end_src
#+begin_export latex
The gene symbol is stored under the key ``Name''.
#+end_export
#+begin_src go <<Search for gene symbol, Ch.~\ref{ch:eg}>>=
  if kv[0] == "Name" {
	  sym = kv[1]
  }
#+end_src
#+begin_export latex
If we didn't find a gene ID, we print a warning to the standard error
stream.
#+end_export
#+begin_src go <<Check gene ID, Ch.~\ref{ch:eg}>>=
  if gid == "" {
	  fmt.Fprintf(os.Stderr,
		  "couldn't find gene ID in %q\n",
		  attributes)
  }
#+end_src
#+begin_export latex
We import \ty{fmt} and \ty{os}.
#+end_export
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "fmt"
  "os"
#+end_src
#+begin_export latex
If we didn't find a gene symbol, we print a warning. Also, if we found
a gene symbol but no gene ID, something is bound to be wrong and we
bail with message.
#+end_export
#+begin_src go <<Check gene symbol, Ch.~\ref{ch:eg}>>=
  if sym == "" {
	  fmt.Fprintf(os.Stderr, "couldn't find name in %q\n",
		  attributes)
  } else if gid == "" {
	  log.Fatalf("found name but no gene ID in %q\n",
		  attributes)
  }
#+end_src
#+begin_src latex
  The remaining tokens on the command line are taken as the names of
  input files. The first of these contains the observed IDs. If the IDs
  file doesn't exist, we bail. Otherwise, we open it and scan the
  observed IDs. If desired, we print these observed IDs in a table next
  to their GO terms and exit. But, remember, what we are really
  interested in, is the GO occupancy. So once we've read the gene IDs,
  we convert them to GO counts.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:eg}>>=
  files := flag.Args()
  if len(files) < 1 {
	  log.Fatal("please enter a file with observed IDs")
  }
  //<<Open observed IDs file, Ch.~\ref{ch:eg}>>
  //<<Scan observed IDs file, Ch.~\ref{ch:eg}>>
  if *optG != "" {
	  //<<Print GO/sym table, Ch.~\ref{ch:eg}>>
	  os.Exit(0)
  }
  //<<Convert observed IDs to GO counts, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  We open the observed IDs file and defer closing it again, as
  usual.
#+end_src
#+begin_src go <<Open observed IDs file, Ch.~\ref{ch:eg}>>=
  f = util.Open(files[0])
  defer f.Close()
#+end_src
#+begin_src latex
  We scan the observed IDs, which we assume to be presented in a single
  column. If there is more than one column, we bail with a message.
#+end_src
#+begin_src go <<Scan observed IDs file, Ch.~\ref{ch:eg}>>=
  sc = bufio.NewScanner(f)
  ids := make([]string, 0)
  for sc.Scan() {
	  fields := strings.Fields(sc.Text())
	  if len(fields) > 1 {
		  m := "gene IDs should be " +
			  "in a single column"
		  log.Fatal(m)
	  }
	  ids = append(ids, fields[0])
  }
#+end_src
#+begin_src latex
  We construct the GO/sym table, sort it, and print it.
#+end_src
#+begin_src go <<Print GO/sym table, Ch.~\ref{ch:eg}>>=
  //<<Construct GO/sym table, Ch.~\ref{ch:eg}>>
  //<<Sort GO/sym table, Ch.~\ref{ch:eg}>>
  //<<Print sorted Go/sym table, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  For each gene ID, we look up the symbol. Then we iterate over the GO
  terms associated with the gene ID.
#+end_src
#+begin_src go <<Construct GO/sym table, Ch.~\ref{ch:eg}>>=
  g2s := make(map[string][]string)
  for _, id := range ids {
	  sym := id2sym[id]
	  gterms := id2go[id]
	  //<<Iterate over GO terms for ID, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  We add the gene symbol to the symbol slice of each GO term. For GO
  terms that don't have a symbol slice yet, we create one.
#+end_src
#+begin_src go <<Iterate over GO terms for ID, Ch.~\ref{ch:eg}>>=
  for gterm, _ := range gterms {
	  sl := g2s[gterm]
	  if sl == nil {
		  sl = make([]string, 0)
	  }
	  sl = append(sl, sym)
	  g2s[gterm] = sl
  }
#+end_src
#+begin_src latex
  To sort the GO/sym table by GO term, we store the GO terms and their
  associated symbols in a slice of type \ty{gosym}. This can be sorted
  by casting to type \ty{gosymSlice}. While constructing the \ty{gosym}
  slice, we also sort the symbols slices alphabetically.
#+end_src
#+begin_src go <<Sort GO/sym table, Ch.~\ref{ch:eg}>>=
  var gosyms []*gosym
  for g, symbols := range g2s {
	  gs := new(gosym)
	  gs.g = g
	  sort.Strings(symbols)
	  gs.s = symbols
	  gosyms = append(gosyms, gs)
  }
  sort.Sort(gosymSlice(gosyms))
#+end_src
#+begin_src latex
  We import \ty{sort}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "sort"
#+end_src
#+begin_src latex
  We declare the type \ty{gosym} as a struct with a string to hold the
  GO term and a slice of strings for the symbols.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type gosym struct {
	  g string
	  s []string
  }
#+end_src
#+begin_src latex
  We also declare the type \ty{gosymSlice} as a slice of pointers go
  \ty{gosym}.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type gosymSlice []*gosym
#+end_src
#+begin_src latex
  To make \ty{gosymSlice} sortable, we implement the three methods of
  the \ty{Sort} interface, \ty{Len}, \ty{Less}, and \ty{Swap}. \ty{Len}
  and \ty{Swap} are standard.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:eg}>>=
  func (g gosymSlice) Len() int {
	  return len(g)
  }
  func (g gosymSlice) Swap(i, j int) {
	  g[i], g[j] = g[j], g[i]
  }
#+end_src
#+begin_src latex
  The actual sorting is done according to the number of symbols
  associated with the GO term. In case of equal numbers, the GO term is
  sorted alphabetically.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:eg}>>=
  func (g gosymSlice) Less(i, j int) bool {
	  l1 := len(g[i].s)
	  l2 := len(g[j].s)
	  if l1 != l2 {
		  return l1 < l2
	  }
	  return g[i].g < g[j].g
  }
#+end_src
#+begin_src latex
  We print the sorted GO/sym table in order of descending symbol number
  using a tab writer. First we print the gene ID, the number of symbols,
  the GO category, and the GO description. Then we print the symbols and
  close the line with a newline. Th the end, we flush the tab writer.
#+end_src
#+begin_src go <<Print sorted Go/sym table, Ch.~\ref{ch:eg}>>=
  w := tabwriter.NewWriter(os.Stdout, 1, 0, 2, ' ', 0)
  for i := len(gosyms)-1; i >= 0; i-- {
	  gosym := gosyms[i]
	  fmt.Fprintf(w, "%s\t%d\t%s\t%s\t", gosym.g,
		  len(gosym.s), go2cat[gosym.g],
		  go2descr[gosym.g])
	  //<<Print symbols, Ch.~\ref{ch:eg}>>
	  fmt.Fprintf(w, "\n")
  }
  w.Flush()
#+end_src
#+begin_export latex
We import \ty{tabwriter}.
#+end_export
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "text/tabwriter"
#+end_src
#+begin_export latex
We print the symbols as a blank-delimited list.
#+end_export
#+begin_src go <<Print symbols, Ch.~\ref{ch:eg}>>=
  for i, symbol := range gosym.s {
	  if i > 0 {
		  fmt.Fprintf(w, " ")
	  }
	  fmt.Fprintf(w, "%s", symbol)
  }
#+end_src
#+begin_src latex
  The conversion between ID lists and GO occupancy is carried out
  here and again later when we read the expected lists. So we delegate
  it to a call to the function \ty{gid2go}.
#+end_src
#+begin_src go <<Convert observed IDs to GO counts, Ch.~\ref{ch:eg}>>=
  obsGOcounts := gid2go(ids, id2go)
#+end_src
#+begin_src latex
  Inside \ty{gid2go}, we allocate a map for the GO counts and iterate
  over the gene IDs. For each ID we look up its associated GO IDs, which
  we count.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:eg}>>=
  func gid2go(ids []string,
	  id2go map[string]map[string]bool) map[string]int {
	  og := make(map[string]int)
	  for _, id := range ids {
		  //<<Count GO IDs for gene, Ch.~\ref{ch:eg}>>
	  }
	  return og
  }
#+end_src
#+begin_src latex
  We skip the gene IDs for which we cannot look up GO IDs.
#+end_src
#+begin_src go <<Count GO IDs for gene, Ch.~\ref{ch:eg}>>=
  gm := id2go[id]
  if gm == nil { continue }
  for g, _ := range gm {
	  og[g]++
  }
#+end_src
#+begin_src latex
  The remaining files contain expected sets of symbols. They are scanned
  in turn using the function \ty{scan}, which takes as arguments the
  observed GO counts, the map from ID to GO, the map from GO to its
  description, the map from GO to its category, and the minimum
  occupancy of a GO term.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:eg}>>=
  files = files[1:]
  clio.ParseFiles(files, scan, obsGOcounts,
	  id2go, go2descr, go2cat, *optM)
#+end_src
#+begin_src latex
  Inside \ty{scan}, we retrieve the arguments, prepare the enrichment
  analysis, scan the file, and analyze the IDs. Once we have scanned all
  IDs, the last set of IDs still remains to be analyzed before we report
  the enrichment analysis.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:eg}>>=
  func scan(r io.Reader, args ...interface{}) {
	  //<<Retrieve arguments, Ch.~\ref{ch:eg}>>
	  sc := bufio.NewScanner(r)
	  //<<Prepare enrichment analysis, Ch.~\ref{ch:eg}>>
	  for sc.Scan() {
		  //<<Analyze IDs, Ch.~\ref{ch:eg}>>
	  }
	  //<<Analyze last set of IDs, Ch.~\ref{ch:eg}>>
	  //<<Report enrichment analysis, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  We import \ty{io}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "io"
#+end_src
#+begin_src latex
  We retrieve the five arguments passed to \ty{scan}.
#+end_src
#+begin_src go  <<Retrieve arguments, Ch.~\ref{ch:eg}>>=
  obsGOcounts := args[0].(map[string]int)
  id2go := args[1].(map[string]map[string]bool)
  go2descr := args[2].(map[string]string)
  go2cat := args[3].(map[string]string)
  minOcc := args[4].(int)
#+end_src
#+begin_src latex
  The enrichment analysis depends on the number of samples we analyze
  and the IDs they contain, so we declare variables for these two
  things. In addition, there are two statistics we produce, the expected
  occupancy of the observed GO terms, and the frequency with which a
  random occupancy is at least as great as that observed
  (Table~\ref{tab:eg}B). So we allocate a map to sum up the expected GO
  counts, and another map to count excessive GO counts.
#+end_src
#+begin_src go <<Prepare enrichment analysis, Ch.~\ref{ch:eg}>>=
  n := 0
  ids := make([]string, 0)
  expGOcounts := make(map[string]int)
  eCounts := make(map[string]int)
#+end_src
#+begin_src latex
  Whenever we encounter a blank line, we've traversed a sample. At that
  point we increment our sample counter, convert the IDs to GO counts,
  analyze them, and reset the table of IDs.
#+end_src
#+begin_src go <<Analyze IDs, Ch.~\ref{ch:eg}>>=
  fields := strings.Fields(sc.Text())
  if len(fields) > 1 {
	  log.Fatalf("can't parse %q", sc.Text())
  }
  if sc.Text() == "" {
	  n++
	  eg := gid2go(ids, id2go)
	  //<<Analyze GO counts, Ch.~\ref{ch:eg}>>
	  ids = ids[:0]
  } else {
	  ids = append(ids, fields[0])
  }
#+end_src
#+begin_src latex
  We iterate over the GO terms found in the expected sample and
  concentrate on those also contained in the observed sample. Their
  occupancy is summed and terms where the expected occupancy is at least
  as great as that observed are counted.
#+end_src
#+begin_src go <<Analyze GO counts, Ch.~\ref{ch:eg}>>=
  for k, e := range eg {
	  o := obsGOcounts[k]
	  if o == 0 { continue }
	  expGOcounts[k] += e
	  if e >= o {
		  eCounts[k]++
	  }
  }
#+end_src
#+begin_src latex
  We analyze the last set of IDs.
#+end_src
#+begin_src go <<Analyze last set of IDs, Ch.~\ref{ch:eg}>>=
  n++
  eg := gid2go(ids, id2go)
  //<<Analyze GO counts, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  We can now report the results of our enrichment analysis. We'd like to
  sort the output by $P$-value. So we declare a type that holds one GO
  term, \ty{GOterm}. It is a structure containing the accession,
  description, and category. It also contains the observed occupancy,
  the expected occupancy, and the $P$-value.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type GOterm struct {
	  a, d, c string
	  o, e, p float64
  }
#+end_src
#+begin_src latex
  We collect the results in a slice of GO terms. $P$-values of zero are,
  of course just less than one divided by the number of iterations. We
  could write something like $< 0.001$, but this would make it difficult
  to sort the results column by $P$-value. So we mark these values as -1
  instead.
#+end_src
#+begin_src go <<Report enrichment analysis, Ch.~\ref{ch:eg}>>=
  GOterms := make([]*GOterm, 0)
  for a, o := range obsGOcounts {
	  gt := new(GOterm)
	  gt.a = a
	  gt.d = go2descr[a]
	  gt.c = go2cat[a]
	  gt.o = float64(o)
	  gt.e = float64(expGOcounts[a]) / float64(n)
	  gt.p = float64(eCounts[a]) / float64(n)
	  if gt.p == 0 { gt.p = -1 }
	  GOterms = append(GOterms, gt)
  }
#+end_src
#+begin_src latex
  We declare a slice of GO terms.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type GOslice []*GOterm
#+end_src
#+begin_src latex
  To make the slice sortable, we implement the methods of the \ty{Sort}
  interface, \ty{Len}, \ty{Less}, and \ty{Swap}. We do \ty{Len} and
  \ty{Swap} first, as they are standard.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:eg}>>=
  func (g GOslice) Len() int { return len(g) }
  func (g GOslice) Swap(i, j int) {
	  g[i], g[j] = g[j], g[i]
  }
#+end_src
#+begin_src latex
  The actual sorting is done according to $P$-value. If $P$-values are
  identical, we sort by descending enrichment ratio. If all else fails,
  we sort the GO accessions alphabetically.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:eg}>>=
  func (g GOslice) Less(i, j int) bool {
	  if g[i].p != g[j].p {
		  return g[i].p < g[j].p
	  }
	  er1 := g[i].o / g[i].e
	  er2 := g[j].o / g[j].e
	  if er1 != er2 {
		  return er1 > er2
	  }
	  return g[i].a < g[j].a
  }
#+end_src
#+begin_src latex
  We sort the results and print the terms with minimum occupancy to a
  table. In the table header we also pass the number of iterations to
  help with downstream analyses.
#+end_src
#+begin_src go <<Report enrichment analysis, Ch.~\ref{ch:eg}>>=
  sort.Sort(GOslice(GOterms))
  w := tabwriter.NewWriter(os.Stdout, 1, 0, 2, ' ', 0)
  fmt.Fprintf(w, "#GO\tO\tE\tO/E\tP(n=%.1e)\t", float64(n))
  fmt.Fprint(w, "Category\tDescription\n")
  for _, g := range GOterms {
	  if int(g.o) < minOcc { continue }
	  fmt.Fprintf(w,
		  "%s\t%.3g\t%.3g\t%.3g\t%.3g\t%s\t%s\n",
		  g.a, g.o, g.e, g.o/g.e, g.p, g.c, g.d)
  }
  w.Flush()
#+end_src
#+begin_src latex
  We import \ty{sort}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "sort"
#+end_src
#+begin_src latex
  We're finished writing \ty{ego}, so let's test it.
  \section*{Testing}
  The outline of our testing program has hooks for imports and the
  testing logic.
#+end_src
#+begin_src go <<ego_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:eg}>>
  )
  func TestEgo(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  We construct the tests and run them.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:eg}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Ch.~\ref{ch:eg}>>
  for i, test := range tests {
	  //<<Run test, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  To begin with, we run \ty{ego} on a list of IDs obtained by shuffling
  \ty{i1.txt} and annotating the intervals.
#+end_src
#+begin_src go <<Construct tests, Ch.~\ref{ch:eg}>>=
  ge := "../data/gene2go"
  ob := "../data/obsId.txt"
  ra := "../data/expId.txt"
  test := exec.Command("./ego", "-o", ge, ob, ra)
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We import \ty{exec}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:eg}>>=
  "os/exec"
#+end_src
#+begin_src latex
  As a second test, we reduce the minimum number of genes per GO term
  from default ten to five.
#+end_src
#+begin_src go <<Construct tests, Ch.~\ref{ch:eg}>>=
  test = exec.Command("./ego", "-o", ge, "-m", "5", ob, ra)
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We run the test and compare what we get with what we want, which is
  contained in \ty{r1.txt} and \ty{r2.txt}.
#+end_src
#+begin_src go <<Run test, Ch.~\ref{ch:eg}>>=
  get, err := test.Output()
  if err != nil {
	  t.Errorf("can't run %q", test)
  }
  f := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := ioutil.ReadFile(f)
  if err != nil {
	  t.Errorf("can't open %q", f)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_src latex
  We import \ty{strconv}, \ty{ioutil}, and \ty{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:eg}>>=
  "strconv"
  "io/ioutil"
  "bytes"
#+end_src
