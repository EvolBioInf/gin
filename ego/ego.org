#+begin_src latex
  \section*{Introduction}
  The program \ty{ego} tests for enrichment of GO terms in a list of
  gene symbols. It does so by reading the observed list of gene symbols
  (Table~\ref{tab:eg}) and multiple symbol lists that together represent
  the null distribution of symbol picks. These random lists can be
  generated by the program \ty{shuffle}. \ty{ego} then calculates the
  frequency with which each GO category occupied by one of the symbols
  found in the observed list has at least an equal occupancy in the
  expected lists. This frequency is the $P$-value for enrichment of that
  category, that is, the error probability when rejecting the null
  hypothesis that the observed occupancy is due to chance alone.

  \begin{table}
    \caption{A list of observed gene symbols (\textbf{A}) is transformed
      by \ty{ego} into a list of GO-IDs and their enrichment
      (\textbf{B}).}\label{tab:eg}
    \begin{center}
      \begin{tabular}{cc}
	\textbf{A} & \textbf{B}\\
	\input{egoTab1} & \input{egoTab2}
      \end{tabular}
    \end{center}
  \end{table}

  Apart from the observed symbols, the program reads two data files to
  map the symbols first onto gene-IDs and from there onto
  GO-IDs. Mapping symbols onto gene-IDs is done using a gene-info file,
  e.g.
  \begin{verbatim}
  ftp://ftp.ncbi.nih.gov/gene/DATA/GENE_INFO/\
  Mammalia/Homo_sapiens.gene_info.gz
  \end{verbatim}
  Mapping the gene-IDs onto GO-IDs is done using the file \ty{gene2go}
  available from
  \begin{verbatim}
  ftp://ftp.ncbi.nih.gov/gene/DATA/gene2go.gz
  \end{verbatim}

  \section*{Implementation}
  The outline of \ty{ego} contains hooks for imports, types, methods,
  functions, and the logic of the main function.
#+end_src
#+begin_src go <<ego.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:eg}>>
  )
  //<<Types, Ch.~\ref{ch:eg}>>
  //<<Methods, Ch.~\ref{ch:eg}>>
  //<<Functions, Ch.~\ref{ch:eg}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  In the main function, we set the usage, declare the options, parse the
  options, and parse the input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:eg}>>=
  //<<Set usage, Ch.~\ref{ch:eg}>>
  //<<Declare options, Ch.~\ref{ch:eg}>>
  //<<Parse options, Ch.~\ref{ch:eg}>>
  //<<Parse input files, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  The usage consists of the actual usage message, an explanation of the
  purpose of \ty{ego}, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:eg}>>=
  u := "ego [-h] -i geneInfo.txt [option]... " +
	  "obsSym.txt [expSym.txt]..."
  p := "Calculate enrichment of GO terms for " +
	  "observed list of gene symbols."
  e := "ego -i Homo_sapiens.gene_info -g gene2go " +
	  "obsSym.txt expSym.txt"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  Apart from the version, \ty{-v}, we declare three options, the first
  for the gene info file (\ty{-i}), the second for the file containing
  the GO terms (\ty{-g}), and the third for the minimum occupancy of a
  GO term to be included in the final result (\ty{-m}).
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:eg}>>=
  var optV = flag.Bool("v", false, "print program option " +
	  "and other information")
  var optI = flag.String("i", "", "information file of gene " +
	  "symbols and IDs")
  var optG = flag.String("g", "gene2go", "GO file of gene " +
	  "IDs and GO terms")
  var optM = flag.Int("m", 10, "minimum occupancy of GO term")
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "flag"
#+end_src
#+begin_src latex
  We parse the options and respond to \ty{-v} as this stops the
  program. We also read the gene-info file specified with \ty{-i} into a
  variable that maps gene symbols to IDs, \ty{sym2id}. If the user didn't
  set a gene-info file, we bail with a friendly message. We also read
  the GO file specified with \ty{-g}.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:eg}>>=
  flag.Parse()
  if *optV {
	  util.PrintInfo("ego")
  }
  sym2id := make(map[string]string)
  if *optI != "" {
	  //<<Read gene-info file, Ch.~\ref{ch:eg}>>
  } else {
	  fmt.Fprintf(os.Stderr, "please enter a gene-info file\n")
	  os.Exit(-1)
  }
  //<<Read GO file, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  We import \ty{util}, \ty{fmt}, and \ty{os}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "github.com/evolbioinf/biobox/util"
  "fmt"
  "os"
#+end_src
#+begin_src latex
  We open the gene-info file and parse it. The gene ID is in the second
  column, the gene symbol in the third. We skip the hashed header line.
#+end_src
#+begin_src go <<Read gene-info file, Ch.~\ref{ch:eg}>>=
  f, err := os.Open(*optI)
  if err != nil {
	  log.Fatalf("can't open %q", *optI)
  }
  defer f.Close()
  sc := bufio.NewScanner(f)
  for sc.Scan() {
	  if sc.Text()[0] == '#' { continue }
	  fields := strings.Fields(sc.Text())
	  sym2id[fields[2]] = fields[1]
  }
#+end_src
#+begin_src latex
  We import \ty{log}, \ty{bufio}, and \ty{strings}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "log"
  "bufio"
  "strings"
#+end_src
#+begin_src latex
  From the GO file we extract a map of gene IDs in column 2 to to GO
  terms in column 3. Again, we skip the hashed header.
#+end_src
#+begin_src go <<Read GO file, Ch.~\ref{ch:eg}>>=
  id2go := make(map[string]string)
  f, err := os.Open(*optG)
  if err != nil {
	  log.Fatalf("can't open %q", *optG)
  }
  defer f.Close()
  sc := bufio.NewScanner(f)
  for sc.Scan() {
	  if sc.Text()[0] == '#' { continue }
	  fields := strings.Fields(sc.Text())
	  id2go[fields[1]] = fields[2]
  }
#+end_src
#+begin_src latex
  The remaining tokens on the command line are taken as the names of
  input files. The first of these contains the observed symbols. If it
  doesn't exist, we bail. Otherwise, we open it and scan the observed
  symbols. But, remember, what we are really interested in, is their GO
  occupancy. So once we've read the gene symbols, we convert them to GO
  counts.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:eg}>>=
  files := flag.Args()
  if len(files) < 1 {
	  log.Fatal("please enter a file with observed symbols")
  }
  //<<Open observed symbols file, Ch.~\ref{ch:eg}>>
  //<<Scan observed symbols file, Ch.~\ref{ch:eg}>>
  //<<Convert observed symbols to GO counts, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  We open the observed symbols file and defer closing it again, as
  usual.
#+end_src
#+begin_src go <<Open observed symbols file, Ch.~\ref{ch:eg}>>=
  f, err = os.Open(files[0])
  if err != nil {
	  log.Fatalf("can't open %q", files[0])
  }
  defer f.Close()
#+end_src
#+begin_src latex
  We scan the observed symbols, which we assume to be presented in a
  single column. If there are more than one column, we bail with a message.
#+end_src
#+begin_src go <<Scan observed symbols file, Ch.~\ref{ch:eg}>>=
  sc = bufio.NewScanner(f)
  symbols := make([]string, 0)
  for sc.Scan() {
	  fields := strings.Fields(sc.Text())
	  if len(fields) > 1 {
		  m := "gene symbols should be " +
			  "in a single column"
		  log.Fatal(m)
	  }
	  symbols = append(symbols, fields[0])
  }
#+end_src
#+begin_src latex
  The conversion between symbol lists and GO occupancy is carried out
  here and later when we read the expected lists. So we delegate it to a
  function call.
#+end_src
#+begin_src go <<Convert observed symbols to GO counts, Ch.~\ref{ch:eg}>>=
  obsGOcounts := sym2go(symbols, sym2id, id2go)
#+end_src
#+begin_src latex
  Inside \ty{sym2go}, we allocate a map for the GO counts and iterate over
  the symbols. For each symbol, we first look up its gene ID and then
  its GO term, which we count. We skip the symbols for which we cannot
  look up a GO term.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:eg}>>=
  func sym2go(sym []string, sym2id, id2go map[string]string) map[string]int {
	  og := make(map[string]int)
	  for _, s := range sym {
		  id := sym2id[s]
		  g := id2go[id]
		  if g == "" { continue }
		  og[g]++
	  }
	  return og
  }
#+end_src
#+begin_src latex
  The remaining files contain expected sets of symbols. They are scanned
  in turn using the function \ty{scan}, which takes as arguments the
  observed GO counts, the map from symbol to ID, the map from ID to
  GO, and the minimum occupancy of a GO term.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:eg}>>=
  files = files[1:]
  clio.ParseFiles(files, scan, obsGOcounts, sym2id, id2go, *optM)
#+end_src
#+begin_src latex
  Inside \ty{scan}, we retrieve the arguments, prepare the enrichment
  analysis, scan the file and analyze the symbols. Once we have scanned
  all symbols, the last set of symbols still remains to be analyzed
  before we report the enrichment analysis.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:eg}>>=
  func scan(r io.Reader, args ...interface{}) {
	  //<<Retrieve arguments, Ch.~\ref{ch:eg}>>
	  sc := bufio.NewScanner(r)
	  //<<Prepare enrichment analysis, Ch.~\ref{ch:eg}>>
	  for sc.Scan() {
		  //<<Analyze symbols, Ch.~\ref{ch:eg}>>
	  }
	  //<<Analyze last set of symbols, Ch.~\ref{ch:eg}>>
	  //<<Report enrichment analysis, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  We import \ty{io}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "io"
#+end_src
#+begin_src latex
  We retrieve the three arguments passed to \ty{scan}.
#+end_src
#+begin_src go  <<Retrieve arguments, Ch.~\ref{ch:eg}>>=
  obsGOcounts := args[0].(map[string]int)
  sym2id := args[1].(map[string]string)
  id2go := args[2].(map[string]string)
  minOcc := args[3].(int)
#+end_src
#+begin_src latex
  The enrichment analysis depends on the number of samples we analyze
  and the symbols they contain, so we declare variables for these two
  things. In addition, there are two statistics we produce, the expected
  occupancy of the observed GO terms, and the frequency, with which a
  random occupancy is at least as great as that observed
  (Table~\ref{tab:eg}B). So we allocate a map to sum up the expected GO
  counts, and another map to count excessive GO counts.
#+end_src
#+begin_src go <<Prepare enrichment analysis, Ch.~\ref{ch:eg}>>=
  n := 0
  symbols := make([]string, 0)
  expGOcounts := make(map[string]int)
  eCounts := make(map[string]int)
#+end_src
#+begin_src latex
  Whenever we encounter a blank line, we've traversed a sample. In that
  case, we increment our sample counter, convert the symbols to GO
  counts, analyze them, and reset the table of symbols.
#+end_src
#+begin_src go <<Analyze symbols, Ch.~\ref{ch:eg}>>=
  fields := strings.Fields(sc.Text())
  if len(fields) > 1 {
	  log.Fatalf("can't parse %q", sc.Text())
  }
  if sc.Text() == "" {
	  n++
	  eg := sym2go(symbols, sym2id, id2go)
	  //<<Analyze GO counts, Ch.~\ref{ch:eg}>>
	  symbols = symbols[:0]
  } else {
	  symbols = append(symbols, fields[0])
  }
#+end_src
#+begin_src latex
  We iterate over the GO terms found in the expected sample and
  concentrate on those contained in the observed sample. Their occupancy
  is summed and terms where the expected occupancy is at least as great
  as that observed are counted.
#+end_src
#+begin_src go <<Analyze GO counts, Ch.~\ref{ch:eg}>>=
  for k, e := range eg {
	  o := obsGOcounts[k]
	  if o == 0 { continue }
	  expGOcounts[k] += e
	  if e >= o {
		  eCounts[k]++
	  }
  }
#+end_src
#+begin_src latex
  We analyze the last set of symbols.
#+end_src
#+begin_src go <<Analyze last set of symbols, Ch.~\ref{ch:eg}>>=
  n++
  eg := sym2go(symbols, sym2id, id2go)
  //<<Analyze GO counts, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  We can now report the results of our enrichment analysis. We'd like to
  sort the output by $P$-value. So we declare a type that holds one GO
  term, \ty{GOterm}. It is a structure containing the accession, the
  observed occupancy, the expected occupancy, and the $P$-value.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type GOterm struct {
	  a string
	  o, e, p float64
  }
#+end_src
#+begin_src latex
  We collect the results in a slice of GO terms. $P$-values of zero are,
  of course just less than the number of iterations. We could write
  something like $< 0.001$, but this would make it difficult to sort the
  results column by $P$-value. So we mark these values as -1 instead.
#+end_src
#+begin_src go <<Report enrichment analysis, Ch.~\ref{ch:eg}>>=
  GOterms := make([]*GOterm, 0)
  for a, o := range obsGOcounts {
	  gt := new(GOterm)
	  gt.a = a
	  gt.o = float64(o)
	  gt.e = float64(expGOcounts[a]) / float64(n)
	  gt.p = float64(eCounts[a]) / float64(n)
	  if gt.p == 0 { gt.p = -1 }
	  GOterms = append(GOterms, gt)
  }
#+end_src
#+begin_src latex
  We declare a slice of GO terms.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type GOslice []*GOterm
#+end_src
#+begin_src latex
  To make the slice sortable, we implement the methods that fulfill the
  \ty{Sort} interface, \ty{Len}, \ty{Less}, and \ty{Swap}.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:eg}>>=
  func (g GOslice) Len() int { return len(g) }
  func (g GOslice) Less(i, j int) bool {
	  return g[i].p < g[j].p
  }
  func (g GOslice) Swap(i, j int) {
	  g[i], g[j] = g[j], g[i]
  }
#+end_src
#+begin_src latex
  We sort the results and print the terms with minimum occupancy them to
  a table.
#+end_src
#+begin_src go <<Report enrichment analysis, Ch.~\ref{ch:eg}>>=
  sort.Sort(GOslice(GOterms))
  w := tabwriter.NewWriter(os.Stdout, 1, 0, 2, ' ', 0)
  fmt.Fprintf(w, "#GO\tO\tE\tO/E\tP\n")
  for _, g := range GOterms {
	  if int(g.o) < minOcc { continue }
	  fmt.Fprintf(w, "%s\t%.3g\t%.3g\t%.3g\t%.3g\n",
		  g.a, g.o, g.e, g.o/g.e, g.p)
  }
  w.Flush()
#+end_src
#+begin_src latex
  We import \ty{sort} and \ty{tabwriter}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "sort"
  "text/tabwriter"
#+end_src
#+begin_src latex
  We're finished writing \ty{ego}, so let's test it.
  \section*{Testing}
  The outline of our testing program has hooks for imports and the
  testing logic.
#+end_src
#+begin_src go <<ego_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:eg}>>
  )
  func TestEgo(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  We construct one test and run it.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:eg}>>=
  //<<Construct test, Ch.~\ref{ch:eg}>>
  //<<Run test, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  We run \ty{ego} on a list of symbols obtained by shuffling \ty{i1.txt}
  and annotating the intervals.
#+end_src
#+begin_src go <<Construct test, Ch.~\ref{ch:eg}>>=
  in := "../data/Homo_sapiens.gene_info"
  ge := "../data/gene2go"
  ob := "../data/obsSym.txt"
  ra := "../data/ranSym.txt"
  test := exec.Command("./ego", "-i", in, "-g", ge, ob, ra)
#+end_src
#+begin_src latex
  We import \ty{exec}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:eg}>>=
  "os/exec"
#+end_src
#+begin_src latex
  We run the test and compare what we get with what we want, which is
  contained in \ty{r.txt}.
#+end_src
#+begin_src go <<Run test, Ch.~\ref{ch:eg}>>=
  get, err := test.Output()
  if err != nil {
	  t.Errorf("can't run %q", test)
  }
  f := "r.txt"
  want, err := ioutil.ReadFile(f)
  if err != nil {
	  t.Errorf("can't open %q", f)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s", get, want)
  }
#+end_src
#+begin_src latex
  We import \ty{ioutil} and \ty{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:eg}>>=
  "io/ioutil"
  "bytes"
#+end_src
