#+begin_src latex
  \section*{Introduction}
  The program \ty{ego} tests for enrichment of GO terms in a list of
  gene symbols. It does so by reading the observed list of gene symbols
  (Table~\ref{tab:eg}) and multiple symbol lists that together represent
  the null distribution of symbol picks. These random lists can be
  generated by the program \ty{shuffle}. \ty{ego} then calculates the
  frequency with which each GO category occupied by one of the symbols
  found in the observed list has at least an equal occupancy in the
  expected lists. This frequency is the $P$-value for enrichment of that
  category, that is, the error probability when rejecting the null
  hypothesis that the observed occupancy is due to chance alone.

  \begin{table}
    \caption{A list of observed gene symbols (\textbf{A}) is transformed
      by \ty{ego} into a list of GO-IDs and their enrichment
      (\textbf{B}).}\label{tab:eg}
    \begin{center}
      \begin{tabular}{cc}
	\textbf{A} & \textbf{B}\\
	\input{egoTab1} & \input{egoTab2}
      \end{tabular}
    \end{center}
  \end{table}

  Apart from the observed symbols, the program reads two data files to
  map the symbols first onto gene-IDs and from there onto
  GO-IDs. Mapping symbols onto gene-IDs is done using a gene-info file,
  e.g.
  \begin{verbatim}
  ftp://ftp.ncbi.nih.gov/gene/DATA/GENE_INFO/\
  Mammalia/Homo_sapiens.gene_info.gz
  \end{verbatim}
  Mapping the gene-IDs onto GO-IDs is done using the file \ty{gene2go}
  available from
  \begin{verbatim}
  ftp://ftp.ncbi.nih.gov/gene/DATA/gene2go.gz
  \end{verbatim}

  As an auxiliary functionality \ty{ego} can also classify the input
  symbols into their GO categories and print what I call a GO/sym table,
  for example Table~\ref{tab:eg2}

  \begin{table}
    \caption{Example GO/sym table.}\label{tab:eg2}
    \begin{center}
      \resizebox{\textwidth}{!}{
	\begin{tabular}{cclll}
	\hline
	GO & Count & Category & Description & Sym\\\hline
	\input{egoTab3}
	\hline
	\end{tabular}
      }
    \end{center}
  \end{table}

  \section*{Implementation}
  The outline of \ty{ego} contains hooks for imports, types, methods,
  functions, and the logic of the main function.
#+end_src
#+begin_src go <<ego.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:eg}>>
  )
  //<<Types, Ch.~\ref{ch:eg}>>
  //<<Methods, Ch.~\ref{ch:eg}>>
  //<<Functions, Ch.~\ref{ch:eg}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  In the main function, we set the usage, declare the options, parse the
  options, and parse the input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:eg}>>=
  //<<Set usage, Ch.~\ref{ch:eg}>>
  //<<Declare options, Ch.~\ref{ch:eg}>>
  //<<Parse options, Ch.~\ref{ch:eg}>>
  //<<Parse input files, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  The usage consists of the actual usage message, an explanation of the
  purpose of \ty{ego}, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:eg}>>=
  u := "ego [-h] -i geneInfo.txt [option]... " +
	  "obsSym.txt [expSym.txt]..."
  p := "Calculate enrichment of GO terms for " +
	  "observed list of gene symbols."
  e := "ego -i Homo_sapiens.gene_info -g gene2go " +
	  "obsSym.txt expSym.txt"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  Apart from the version, \ty{-v}, we declare four options, the gene
  info file (\ty{-i}), the file containing the GO terms (\ty{-g}), and
  the minimum occupancy of a GO term to be included in the final result
  (\ty{-m}), and whether or not the GO/sym table should be printed (\ty{-p}).
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:eg}>>=
  var optV = flag.Bool("v", false, "version")
  var optI = flag.String("i", "", "information file of gene " +
	  "symbols and IDs")
  var optG = flag.String("g", "gene2go", "GO file of gene " +
	  "IDs and GO terms")
  var optM = flag.Int("m", 10, "minimum occupancy of GO term")
  var optP = flag.Bool("p", false, "print GO/sym table")
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "flag"
#+end_src
#+begin_src latex
  We parse the options and respond to \ty{-v} as this stops the
  program. We also read the gene-info file specified with \ty{-i} into a
  variable that maps gene symbols to gene IDs, \ty{sym2id}. If the user didn't
  set a gene-info file, we bail with a friendly message. We also read
  the GO file specified with \ty{-g}.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:eg}>>=
  flag.Parse()
  if *optV { util.PrintInfo("ego") }
  sym2id := make(map[string]string)
  if *optI != "" {
	  //<<Read gene-info file, Ch.~\ref{ch:eg}>>
  } else {
	  m := "please enter a gene-info file\n"
	  fmt.Fprintf(os.Stderr, m)
	  os.Exit(-1)
  }
  //<<Read GO file, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  We import \ty{util}, \ty{fmt}, and \ty{os}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "github.com/evolbioinf/biobox/util"
  "fmt"
  "os"
#+end_src
#+begin_src latex
  We open the gene-info file and parse it. The gene ID is in the second
  column, the gene symbol in the third. We skip the hashed header line.
#+end_src
#+begin_src go <<Read gene-info file, Ch.~\ref{ch:eg}>>=
  f, err := os.Open(*optI)
  if err != nil {
	  log.Fatalf("can't open %q", *optI)
  }
  defer f.Close()
  sc := bufio.NewScanner(f)
  for sc.Scan() {
	  if sc.Text()[0] == '#' { continue }
	  fields := strings.Fields(sc.Text())
	  sym2id[fields[2]] = fields[1]
  }
#+end_src
#+begin_src latex
  We import \ty{log}, \ty{bufio}, and \ty{strings}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "log"
  "bufio"
  "strings"
#+end_src
#+begin_src latex
  To read the GO file, we open and scan it.
#+end_src
#+begin_src go <<Read GO file, Ch.~\ref{ch:eg}>>=
  //<<Open GO file, Ch.~\ref{ch:eg}>>
  //<<Scan GO file, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  If we can't open the GO file, we bail with message.
#+end_src
#+begin_src go <<Open GO file, Ch.~\ref{ch:eg}>>=
  f, err := os.Open(*optG)
  if err != nil {
	  log.Fatalf("can't open %q", *optG)
  }
  defer f.Close()
  sc := bufio.NewScanner(f)
#+end_src
#+begin_src latex
  We extract the required GO attributes from the GO file. Then we store
  the GO ID as a function of the gene ID. Since a gene ID typically maps
  to many GO IDs, we store the relationship between gene IDs and GO ID
  in a map between gene IDs and maps of GO IDs. We also store the GO
  description and the GO category as functions of the GO ID.
#+end_src
#+begin_src go <<Scan GO file, Ch.~\ref{ch:eg}>>=
  id2go := make(map[string]map[string]bool)
  go2descr := make(map[string]string)
  go2cat := make(map[string]string)
  for sc.Scan() {
	  if sc.Text()[0] == '#' { continue }
	  //<<Extract GO attributes, Ch.~\ref{ch:eg}>>
	  //<<Store GO ID, Ch.~\ref{ch:eg}>>
	  //<<Store GO description, Ch.~\ref{ch:eg}>>
	  //<<Store Go category, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  In the GO file, the gene ID is in column 2, the GO ID in column 3, the
  description of the GO term in column 6, and its category in column
  8.
#+end_src
#+begin_src go <<Extract GO attributes, Ch.~\ref{ch:eg}>>=
  fields := strings.Split(sc.Text(), "\t")
  geneId := fields[1]
  goId := fields[2]
  goDescr := fields[5]
  goCat := fields[7]
#+end_src
#+begin_src latex
  We check whether a given gene ID already has an associated map of GO
  IDs. If not, we make it. Then we store the GO ID.
#+end_src
#+begin_src go <<Store GO ID, Ch.~\ref{ch:eg}>>=
  if id2go[geneId] == nil {
	  id2go[geneId] = make(map[string]bool)
  }
  id2go[geneId][goId] = true
#+end_src
#+begin_src latex
  GO descriptions may end with \verb+[GO-ID]+, which is redundant, so we
  cut it off before storing the description. We also make sure the
  remaining description doesn't end in a blank.
#+end_src
#+begin_src go <<Store GO description, Ch.~\ref{ch:eg}>>=
  li := strings.LastIndex(goDescr, "[")
  if li > -1 && strings.Contains(goDescr, "GO:") {
	  if li > 0 {
		  goDescr = goDescr[:li-1]
	  } else {
		  goDescr = goDescr[:li]
	  }
  }
  go2descr[goId] = goDescr
#+end_src
#+begin_src latex
  We store the GO category.
#+end_src
#+begin_src go <<Store Go category, Ch.~\ref{ch:eg}>>=
  go2cat[goId] = goCat
#+end_src
#+begin_src latex
  The remaining tokens on the command line are taken as the names of
  input files. The first of these contains the observed symbols. If the
  symbols file doesn't exist, we bail. Otherwise, we open it and scan
  the observed symbols. If desired, we print these observed symbols in a
  table next to their GO terms and exit. But, remember, what we are
  really interested in, is the GO occupancy. So once we've read the gene
  symbols, we convert them to GO counts.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:eg}>>=
  files := flag.Args()
  if len(files) < 1 {
	  log.Fatal("please enter a file with observed symbols")
  }
  //<<Open observed symbols file, Ch.~\ref{ch:eg}>>
  //<<Scan observed symbols file, Ch.~\ref{ch:eg}>>
  if *optP {
	  //<<Print GO/sym table, Ch.~\ref{ch:eg}>>
	  os.Exit(0)
  }
  //<<Convert observed symbols to GO counts, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  We open the observed symbols file and defer closing it again, as
  usual.
#+end_src
#+begin_src go <<Open observed symbols file, Ch.~\ref{ch:eg}>>=
  f, err = os.Open(files[0])
  if err != nil {
	  log.Fatalf("can't open %q", files[0])
  }
  defer f.Close()
#+end_src
#+begin_src latex
  We scan the observed symbols, which we assume to be presented in a
  single column. If there is more than one column, we bail with a message.
#+end_src
#+begin_src go <<Scan observed symbols file, Ch.~\ref{ch:eg}>>=
  sc = bufio.NewScanner(f)
  symbols := make([]string, 0)
  for sc.Scan() {
	  fields := strings.Fields(sc.Text())
	  if len(fields) > 1 {
		  m := "gene symbols should be " +
			  "in a single column"
		  log.Fatal(m)
	  }
	  symbols = append(symbols, fields[0])
  }
#+end_src
#+begin_src latex
  We construct the GO/sym table, sort it, and print it.
#+end_src
#+begin_src go <<Print GO/sym table, Ch.~\ref{ch:eg}>>=
  //<<Construct GO/sym table, Ch.~\ref{ch:eg}>>
  //<<Sort GO/sym table, Ch.~\ref{ch:eg}>>
  //<<Print sorted Go/sym table, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  For each symbol, we iterate over its GO terms.
#+end_src
#+begin_src go <<Construct GO/sym table, Ch.~\ref{ch:eg}>>=
  g2s := make(map[string][]string)
  for _, symbol := range symbols {
	  id := sym2id[symbol]
	  gterms := id2go[id]
	  //<<Iterate over GO terms for symbol, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  Each GO term of a symbol is stored in the term's symbols slice.
#+end_src
#+begin_src go <<Iterate over GO terms for symbol, Ch.~\ref{ch:eg}>>=
  for gterm, _ := range gterms {
	  sl := g2s[gterm]
	  if sl == nil {
		  sl = make([]string, 0)
	  }
	  sl = append(sl, symbol)
	  g2s[gterm] = sl
  }
#+end_src
#+begin_src latex
  To sort the GO/sym table by GO term, we store the GO terms and their
  associated symbols in a slice of type \ty{gosym}. This can be sorted
  when cast to type \ty{gosymSlice}. While constructing the \ty{gosym}
  slice, we also sort the symbols slices alphabetically.
#+end_src
#+begin_src go <<Sort GO/sym table, Ch.~\ref{ch:eg}>>=
  var gosyms []*gosym
  for g, symbols := range g2s {
	  gs := new(gosym)
	  gs.g = g
	  sort.Strings(symbols)
	  gs.s = symbols
	  gosyms = append(gosyms, gs)
  }
  sort.Sort(gosymSlice(gosyms))
#+end_src
#+begin_src latex
  We import \ty{sort}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "sort"
#+end_src
#+begin_src latex
  We declare the type \ty{gosym} as a struct with a string to hold the
  GO term and a slice of strings for the symbols.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type gosym struct {
	  g string
	  s []string
  }
#+end_src
#+begin_src latex
  We also declare the type \ty{gosymSlice}.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type gosymSlice []*gosym
#+end_src
#+begin_src latex
  To make \ty{gosymSlice} sortable, we implement the three methods of
  the \ty{Sort} interface, \ty{Len}, \ty{Less}, and \ty{Swap}. \ty{Len}
  and \ty{Swap} are standard.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:eg}>>=
  func (g gosymSlice) Len() int {
	  return len(g)
  }
  func (g gosymSlice) Swap(i, j int) {
	  g[i], g[j] = g[j], g[i]
  }
#+end_src
#+begin_src latex
  The actual sorting is done according to the number of symbols
  associated with the GO term. In case of equal numbers, the GO term is
  sorted alphabetically.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:eg}>>=
  func (g gosymSlice) Less(i, j int) bool {
	  l1 := len(g[i].s)
	  l2 := len(g[j].s)
	  if l1 != l2 {
		  return l1 < l2
	  }
	  return g[i].g < g[j].g
  }
#+end_src
#+begin_src latex
  We print the sorted GO/sym table in order of descending symbol number.
#+end_src
#+begin_src go <<Print sorted Go/sym table, Ch.~\ref{ch:eg}>>=
  for i := len(gosyms)-1; i >= 0; i-- {
	  gosym := gosyms[i]
	  fmt.Printf("%s\t%d\t%s\t%s\t", gosym.g, len(gosym.s),
		  go2cat[gosym.g], go2descr[gosym.g])
	  for i, symbol := range gosym.s {
		  if i > 0 { fmt.Printf(" ") }
		  fmt.Printf("%s", symbol)
	  }
	  fmt.Printf("\n")
  }
#+end_src
#+begin_src latex
  The conversion between symbol lists and GO occupancy is carried out
  here and again later when we read the expected lists. So we delegate
  it to a function call.
#+end_src
#+begin_src go <<Convert observed symbols to GO counts, Ch.~\ref{ch:eg}>>=
  obsGOcounts := sym2go(symbols, sym2id, id2go)
#+end_src
#+begin_src latex
  Inside \ty{sym2go}, we allocate a map for the GO counts and iterate over
  the symbols. For each symbol, we first look up its gene ID and then
  its GO IDs, which we count.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:eg}>>=
  func sym2go(sym []string, sym2id map[string]string,
	  id2go map[string]map[string]bool) map[string]int {
	  og := make(map[string]int)
	  for _, s := range sym {
		  id := sym2id[s]
		  //<<Count GO IDs for gene, Ch.~\ref{ch:eg}>>
	  }
	  return og
  }
#+end_src
#+begin_src latex
  We skip the symbols for which we cannot look up GO IDs.
#+end_src
#+begin_src go <<Count GO IDs for gene, Ch.~\ref{ch:eg}>>=
  gm := id2go[id]
  if gm == nil { continue }
  for g, _ := range gm {
	  og[g]++
  }
#+end_src
#+begin_src latex
  The remaining files contain expected sets of symbols. They are scanned
  in turn using the function \ty{scan}, which takes as arguments the
  observed GO counts, the map from symbol to ID, the map from ID to GO,
  the map from GO to its description, the map from GO to its category,
  and the minimum occupancy of a GO term.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:eg}>>=
  files = files[1:]
  clio.ParseFiles(files, scan, obsGOcounts, sym2id,
	  id2go, go2descr, go2cat, *optM)
#+end_src
#+begin_src latex
  Inside \ty{scan}, we retrieve the arguments, prepare the enrichment
  analysis, scan the file and analyze the symbols. Once we have scanned
  all symbols, the last set of symbols still remains to be analyzed
  before we report the enrichment analysis.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:eg}>>=
  func scan(r io.Reader, args ...interface{}) {
	  //<<Retrieve arguments, Ch.~\ref{ch:eg}>>
	  sc := bufio.NewScanner(r)
	  //<<Prepare enrichment analysis, Ch.~\ref{ch:eg}>>
	  for sc.Scan() {
		  //<<Analyze symbols, Ch.~\ref{ch:eg}>>
	  }
	  //<<Analyze last set of symbols, Ch.~\ref{ch:eg}>>
	  //<<Report enrichment analysis, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  We import \ty{io}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "io"
#+end_src
#+begin_src latex
  We retrieve the six arguments passed to \ty{scan}.
#+end_src
#+begin_src go  <<Retrieve arguments, Ch.~\ref{ch:eg}>>=
  obsGOcounts := args[0].(map[string]int)
  sym2id := args[1].(map[string]string)
  id2go := args[2].(map[string]map[string]bool)
  go2descr := args[3].(map[string]string)
  go2cat := args[4].(map[string]string)
  minOcc := args[5].(int)
#+end_src
#+begin_src latex
  The enrichment analysis depends on the number of samples we analyze
  and the symbols they contain, so we declare variables for these two
  things. In addition, there are two statistics we produce, the expected
  occupancy of the observed GO terms, and the frequency with which a
  random occupancy is at least as great as that observed
  (Table~\ref{tab:eg}B). So we allocate a map to sum up the expected GO
  counts, and another map to count excessive GO counts.
#+end_src
#+begin_src go <<Prepare enrichment analysis, Ch.~\ref{ch:eg}>>=
  n := 0
  symbols := make([]string, 0)
  expGOcounts := make(map[string]int)
  eCounts := make(map[string]int)
#+end_src
#+begin_src latex
  Whenever we encounter a blank line, we've traversed a sample. In that
  case, we increment our sample counter, convert the symbols to GO
  counts, analyze them, and reset the table of symbols.
#+end_src
#+begin_src go <<Analyze symbols, Ch.~\ref{ch:eg}>>=
  fields := strings.Fields(sc.Text())
  if len(fields) > 1 {
	  log.Fatalf("can't parse %q", sc.Text())
  }
  if sc.Text() == "" {
	  n++
	  eg := sym2go(symbols, sym2id, id2go)
	  //<<Analyze GO counts, Ch.~\ref{ch:eg}>>
	  symbols = symbols[:0]
  } else {
	  symbols = append(symbols, fields[0])
  }
#+end_src
#+begin_src latex
  We iterate over the GO terms found in the expected sample and
  concentrate on those also contained in the observed sample. Their
  occupancy is summed and terms where the expected occupancy is at least
  as great as that observed are counted.
#+end_src
#+begin_src go <<Analyze GO counts, Ch.~\ref{ch:eg}>>=
  for k, e := range eg {
	  o := obsGOcounts[k]
	  if o == 0 { continue }
	  expGOcounts[k] += e
	  if e >= o {
		  eCounts[k]++
	  }
  }
#+end_src
#+begin_src latex
  We analyze the last set of symbols.
#+end_src
#+begin_src go <<Analyze last set of symbols, Ch.~\ref{ch:eg}>>=
  n++
  eg := sym2go(symbols, sym2id, id2go)
  //<<Analyze GO counts, Ch.~\ref{ch:eg}>>
#+end_src
#+begin_src latex
  We can now report the results of our enrichment analysis. We'd like to
  sort the output by $P$-value. So we declare a type that holds one GO
  term, \ty{GOterm}. It is a structure containing the accession,
  description, and category. It also contains the observed occupancy,
  the expected occupancy, and the $P$-value.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type GOterm struct {
	  a, d, c string
	  o, e, p float64
  }
#+end_src
#+begin_src latex
  We collect the results in a slice of GO terms. $P$-values of zero are,
  of course just less than the number of iterations. We could write
  something like $< 0.001$, but this would make it difficult to sort the
  results column by $P$-value. So we mark these values as -1 instead.
#+end_src
#+begin_src go <<Report enrichment analysis, Ch.~\ref{ch:eg}>>=
  GOterms := make([]*GOterm, 0)
  for a, o := range obsGOcounts {
	  gt := new(GOterm)
	  gt.a = a
	  gt.d = go2descr[a]
	  gt.c = go2cat[a]
	  gt.o = float64(o)
	  gt.e = float64(expGOcounts[a]) / float64(n)
	  gt.p = float64(eCounts[a]) / float64(n)
	  if gt.p == 0 { gt.p = -1 }
	  GOterms = append(GOterms, gt)
  }
#+end_src
#+begin_src latex
  We declare a slice of GO terms.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:eg}>>=
  type GOslice []*GOterm
#+end_src
#+begin_src latex
  To make the slice sortable, we implement the methods of the \ty{Sort}
  interface, \ty{Len}, \ty{Less}, and \ty{Swap}. We do \ty{Len} and
  \ty{Swap} first, as they are standard.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:eg}>>=
  func (g GOslice) Len() int { return len(g) }
  func (g GOslice) Swap(i, j int) {
	  g[i], g[j] = g[j], g[i]
  }
#+end_src
#+begin_src latex
  The actual sorting is done according to $P$-value. If $P$-values are
  identical, we sort by descending enrichment ratio. If all else fails,
  we sort the GO accessions alphabetically.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:eg}>>=
  func (g GOslice) Less(i, j int) bool {
	  if g[i].p != g[j].p {
		  return g[i].p < g[j].p
	  }
	  er1 := g[i].o / g[i].e
	  er2 := g[j].o / g[j].e
	  if er1 != er2 {
		  return er1 > er2
	  }
	  return g[i].a < g[j].a
  }
#+end_src
#+begin_src latex
  We sort the results and print the terms with minimum occupancy to a
  table.
#+end_src
#+begin_src go <<Report enrichment analysis, Ch.~\ref{ch:eg}>>=
  sort.Sort(GOslice(GOterms))
  w := tabwriter.NewWriter(os.Stdout, 1, 0, 2, ' ', 0)
  fmt.Fprintf(w, "#GO\tO\tE\tO/E\tP\tCategory\tDescription\n")
  for _, g := range GOterms {
	  if int(g.o) < minOcc { continue }
	  fmt.Fprintf(w, "%s\t%.3g\t%.3g\t%.3g\t%.3g\t%s\t%s\n",
		  g.a, g.o, g.e, g.o/g.e, g.p, g.c, g.d)
  }
  w.Flush()
#+end_src
#+begin_src latex
  We import \ty{sort} and \ty{tabwriter}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:eg}>>=
  "sort"
  "text/tabwriter"
#+end_src
#+begin_src latex
  We're finished writing \ty{ego}, so let's test it.
  \section*{Testing}
  The outline of our testing program has hooks for imports and the
  testing logic.
#+end_src
#+begin_src go <<ego_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:eg}>>
  )
  func TestEgo(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  We construct the tests and run them.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:eg}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Ch.~\ref{ch:eg}>>
  for i, test := range tests {
	  //<<Run test, Ch.~\ref{ch:eg}>>
  }
#+end_src
#+begin_src latex
  To begin with, we run \ty{ego} on a list of symbols obtained by
  shuffling \ty{i1.txt} and annotating the intervals.
#+end_src
#+begin_src go <<Construct tests, Ch.~\ref{ch:eg}>>=
  in := "../data/Homo_sapiens.gene_info"
  ge := "../data/gene2go"
  ob := "../data/obsSym.txt"
  ra := "../data/ranSym.txt"
  test := exec.Command("./ego", "-i", in, "-g", ge, ob, ra)
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We import \ty{exec}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:eg}>>=
  "os/exec"
#+end_src
#+begin_src latex
  As a second test, we print the GO/sym table.
#+end_src
#+begin_src go <<Construct tests, Ch.~\ref{ch:eg}>>=
  test = exec.Command("./ego", "-i", in, "-g", ge, "-p", ob)
  tests = append(tests, test)
#+end_src
#+begin_src latex
  We run the test and compare what we get with what we want, which is
  contained in \ty{r1.txt} and \ty{r2.txt}.
#+end_src
#+begin_src go <<Run test, Ch.~\ref{ch:eg}>>=
  get, err := test.Output()
  if err != nil {
	  t.Errorf("can't run %q", test)
  }
  f := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := ioutil.ReadFile(f)
  if err != nil {
	  t.Errorf("can't open %q", f)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_src latex
  We import \ty{strconv}, \ty{ioutil}, and \ty{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:eg}>>=
  "strconv"
  "io/ioutil"
  "bytes"
#+end_src
