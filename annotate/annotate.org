#+begin_src latex
  \section*{Introduction}
  The program \ty{annotate} reads a list of genome intervals and an
  annotation file in GFF format. The GFF format consists of the
  following nine columns:
  \begin{enumerate}
  \item Chromosome, e. g. NC\_000007.14
  \item Source, e. g. BestRefSeq
  \item Type, e. g. gene
  \item Start, e. g. 27092993
  \item End, e. g. 27096000
  \item Score, no example available
  \item Strand, $+$ or $-$
  \item Phase, no example available
  \item Attributes, e. g. ID=gene-HOXA1;Dbxref=GeneID:3198,...;Name=HOXA1;...
  \end{enumerate}
  Comment lines are marked by a hash in the first position.

  Given the interval file and the GFF file, \ty{annotate} returns the
  genes that intersect the intervals in a table consisting of four
  columns, chromosome, start, end, and comma-separated gene IDs. Instead
  of gene IDs, \ty{annotate} can also return the gene names, also known
  as ``symbols''. 

  Consider the six genes, $g_1,...,g_6$ in Figure~\ref{fig:iv}. The
  interval $[s,e]$ intersects four of them, $g_5$, $g_4$, $g_3$, and
  $g_2$. However, instead of intersecting whole genes, we can instead
  intersect their promoters. Depending on the promoter length, $g_6$
  might now also intersect the interval, and so might $g_1$, as it is on
  the reverse strand. By default \ty{annotate} intersects
  promoters. These are assumed to have the same length for all genes,
  which can be set by the user.

  \begin{figure}[ht]
    \begin{center}
      \input{../annotate/iv}
    \end{center}
    \caption{Cartoon of a focus interval, $[s,e]$, and six genes,
      $g_1,...,g_6$; the program \ty{annotate} finds the genes, or their
      promoters, that intersect one or more focus
      intervals.}\label{fig:iv}
  \end{figure}


  \section*{Implementation}
  The outline of \ty{annotate} has hooks for types, methods, functions,
  and the logic of the main function.
#+end_src
#+begin_src go <<annotate.go>>=
  package main

  import (
	  //<<Imports, Ch.~\ref{ch:an}>>
  )
  //<<Types, Ch.~\ref{ch:an}>>
  //<<Functions, Ch.~\ref{ch:an}>>
  //<<Methods, Ch.~\ref{ch:an}>>
  func main() {
	  //<<Main function, Ch.~\ref{ch:an}>>
  }	
#+end_src
#+begin_src latex
  In the main function we set the program name, its usage, declare the
  options, parse the options, and parse the input files.
#+end_src
#+begin_src go <<Main function, Ch.~\ref{ch:an}>>=
  util.Name("annotate")
  //<<Set usage, Ch.~\ref{ch:an}>>
  //<<Declare options, Ch.~\ref{ch:an}>>
  //<<Parse options, Ch.~\ref{ch:an}>>
  //<<Parse input files, Ch.~\ref{ch:an}>>
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "github.com/evolbioinf/gin/util"
#+end_src
#+begin_src latex
  The usage consists of three parts, the actual usage message, an
  explanation of the purpose of \ty{annotate}, and an example command.
#+end_src
#+begin_src go <<Set usage, Ch.~\ref{ch:an}>>=
  u := "annotate [-h] [option]... foo.gff [intervals.txt]..."
  p := "Annotate genome intervals with intersecting genes."
  e := "annotate genomic.gff iv.txt"
  clio.Usage(u, p, e)
#+end_src
#+begin_src latex
  We import \ty{clio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "github.com/evolbioinf/clio"
#+end_src
#+begin_src latex
  Apart from the version, \ty{-v}, we declare an option for intersecting
  the full transcript instead of the promoter, \ty{-t}. The user can
  also set the promoter length, \ty{-l}, get gene symbols instead of
  accessions, \ty{-s}, and print the accessions or symbols in a single
  column, \ty{-c}.
#+end_src
#+begin_src go <<Declare options, Ch.~\ref{ch:an}>>=
  var optV = flag.Bool("v", false, "print program version " +
	  "and other information")
  var optT = flag.Bool("t", false, "intersect transcript " +
	  "instead of promoter")
  var optL = flag.Int("l", 2000, "promoter length")
  var optS = flag.Bool("s", false, "gene symbols instead of " +
	  "gene IDs")
  var optC = flag.Bool("c", false, "print gene IDs " +
	  "or gene symbols in a single column")
#+end_src
#+begin_src latex
  We import \ty{flag}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "flag"
#+end_src
#+begin_src latex
  We parse the options, and begin by checking whether the user requested
  the version, as this stops the program.
#+end_src
#+begin_src go <<Parse options, Ch.~\ref{ch:an}>>=
  flag.Parse()
  if *optV {
	  util.Version()
  }
#+end_src
#+begin_src latex
  The remaining tokens on the command line are taken as file names. The
  first of these is interpreted as the file of reference genes. If it
  exists, we read it, if not, we bail with a friendly message. The genes
  are read into slices of intervals indexed by the chromosomes they
  belong to.

  The interval files are parsed by the function \ty{scan}, which takes
  the variable holding the genes as an argument. The intersecting
  intervals are written to a table using a buffered writer. So we
  construct a buffered writer and also pass it as an argument of
  \ty{scan}. The table has a header, which we construct and pass as
  argument. The format of the table we print is determined by \ty{-c},
  so we pass that as well.
#+end_src
#+begin_src go <<Parse input files, Ch.~\ref{ch:an}>>=
  files := flag.Args()
  genes := make(map[string][]*interval, 0)
  if len(files) < 1 {
	  m := "please supply a GFF file"
	  log.Fatal(m)
  } else {
	  //<<Read genes, Ch.~\ref{ch:an}>>
  }
  files = files[1:]
  w := bufio.NewWriter(os.Stdout)
  //<<Construct header, Ch.~\ref{ch:an}>>
  clio.ParseFiles(files, scan, genes, w, header, *optC)
#+end_src
#+begin_src latex
  We import \ty{log}, \ty{bufio}, and \ty{os}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "log"
  "bufio"
  "os"
#+end_src
#+begin_src latex
  Before we read the intervals, we declare an interval as consisting of
  a start, an end, and an identifier.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:an}>>=
  type interval struct {
	  start, end int
	  id string
  }
#+end_src
#+begin_src latex
  We open the annotation file and iterate over its lines. We skip
  any annotation lines starting with a hash and store the genes. Then we
  sort the genes.
#+end_src
#+begin_src go <<Read genes, Ch.~\ref{ch:an}>>=
  f := util.Open(files[0])
  sc := bufio.NewScanner(f)
  for sc.Scan() {
	  t := sc.Text()
	  if t[0] == '#' { continue }
	  //<<Store gene, Ch.~\ref{ch:an}>>
  }
  f.Close()
  //<<Sort genes, Ch.~\ref{ch:an}>>
#+end_src
#+begin_src latex
  We import \ty{util} and \ty{bufio}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "github.com/evolbioinf/gin/util"
  "bufio"
#+end_src
#+begin_src latex
  As described in the Introduction, the genes are specified in the
  annotation file, where column 3 states the annotation type. We're only
  interested in genes. From the gene annotations we determine the gene
  interval before add the gene to the appropriate slice.
#+end_src
#+begin_src go <<Store gene, Ch.~\ref{ch:an}>>=
  fields := strings.Fields(sc.Text())
  if fields[2] == "gene" {
	  gene := new(interval)
	  chr := fields[0]
	  //<<Extract gene information, Ch.~\ref{ch:an}>>
	  //<<Determine gene interval, Ch.~\ref{ch:an}>>
	  //<<Add gene to slice, Chr.~\ref{ch:an}>>
  }
#+end_src
#+begin_src latex
  We import \ty{strings}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "strings"
#+end_src
#+begin_src latex
  We extract the gene information. The transcription start and end are
  converted from columns 4 and 5, the strand from column 6. Column 9
  yields the attributes. We extract the gene ID from the attributes and
  set it.
#+end_src
#+begin_src go <<Extract gene information, Ch.~\ref{ch:an}>>=
  tss, err := strconv.Atoi(fields[3])
  if err != nil { log.Fatal(err.Error()) }
  tes, err := strconv.Atoi(fields[4])
  if err != nil { log.Fatal(err.Error()) }
  str := fields[6]
  attributes := strings.Split(fields[8], ";")
  //<<Set gene ID, Ch.~\ref{ch:an}>>
#+end_src
#+begin_export latex
We import \ty{strconv}.
#+end_export
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "strconv"
#+end_src
#+begin_export latex
The gene ID we store is either the actual gene ID or the gene name,
which is often also called the gene ``symbol''. So we get the gene ID
and the gene name before we set the ID.
#+end_export
#+begin_src go <<Set gene ID, Ch.~\ref{ch:an}>>=
  var gid, name string
  //<<Get gene ID and name, Ch.~\ref{ch:an}>>
  gene.id = gid
  if *optS {
	  gene.id = name
  }
#+end_src
#+begin_export latex
We iterate over the attributes and search for the keys ``Name'' and
``Dbxref''. The value of ``Name'' is just that. The value of
``Dbxref'' is a set of comma-separated IDs among which we search for
the gene ID.
#+end_export
#+begin_src go <<Get gene ID and name, Ch.~\ref{ch:an}>>=
  for _, attribute := range attributes {
	  arr := strings.Split(attribute, "=")
	  if arr[0] == "Name" {
		  name = arr[1]
	  }
	  if arr[0] == "Dbxref" {
		  ids := strings.Split(arr[1], ",")
		  //<<Search for gene ID, Ch.~\ref{ch:an}>>
	  }
  }
#+end_src
#+begin_export latex
A gene ID has the format k:v, so we split the IDs at the first colon
and look for GeneID. If we find it, we store it and break. If we don't
find it, something is wrong and we bail with message.
#+end_export
#+begin_src go <<Search for gene ID, Ch.~\ref{ch:an}>>=
  for _, id := range ids {
	  arr := strings.Split(id, ":")
	  if arr[0] == "GeneID" {
		  gid = arr[1]
		  break
	  }
  }
  if gid == "" {
	  log.Fatal("couldn't find GeneID")
  }
#+end_src
#+begin_src latex
  The gene interval is either the promoter or the transcript.
#+end_src
#+begin_src go <<Determine gene interval, Ch.~\ref{ch:an}>>=
  if *optT {
	  //<<Get gene interval from transcript, Ch.~\ref{ch:an}>>
  } else {
	  //<<Get gene interval from promoter, Ch.~\ref{ch:an}>>
  }
#+end_src
#+begin_src latex
  If the transcript is the relevant gene interval, we read the start and
  end from the TSS and the TES.
#+end_src
#+begin_src go <<Get gene interval from transcript, Ch.~\ref{ch:an}>>=
  gene.start = tss
  gene.end = tes
#+end_src
#+begin_src latex
  If the gene is located on the plus strand, the promoter is upstream of
  the TSS, otherwise, it is downstream of the TES.
#+end_src
#+begin_src go <<Get gene interval from promoter, Ch.~\ref{ch:an}>>=
  if str == "+" {
	  gene.start = tss - *optL + 1
	  gene.end = tss
  } else {
	  gene.start = tes
	  gene.end = tes + *optL - 1
  }
#+end_src
#+begin_src latex
  To sort the gene intervals we just read, we declare the type \ty{ivSlice} that
  wraps an interval slice.
#+end_src
#+begin_src go <<Types, Ch.~\ref{ch:an}>>=
  type ivSlice []*interval
#+end_src
#+begin_src latex
  We implement the methods of the \ty{sort} interface, \ty{Len},
  \ty{Less}, and \ty{Swap} on \ty{ivSlice}. The method \ty{Less}
  determines the sorting order. The desired sorting order depends on our
  method for picking intersecting genes. Focus on the interval $[s,e]$
  and the genes $g_1,...,g_6$ in Figure~\ref{fig:iv}. Moving from left
  to right, we search for the
  first gene that intersects the interval, $g_2$. Then we walk to the right until we find
  the first gene that starts to the right of $e$, $g_6$. This requires that
  we sort the genes with two keys. The primary key is the start
  position, by which we sort them in ascending order. The secondary key
  is the end position, by which we also sort them in ascending order, as
  shown for $g_5$ and $g_6$, which start at the same position.
#+end_src
#+begin_src go <<Methods, Ch.~\ref{ch:an}>>=
  func (s ivSlice) Len() int { return len(s) }
  func (s ivSlice) Less(i, j int) bool {
	  if s[i].start == s[j].start {
		  return s[i].end < s[j].end
	  }
	  return s[i].start < s[j].start
  }
  func (s ivSlice) Swap(i, j int) {
	  s[i], s[j] = s[j], s[i]
  }
#+end_src
#+begin_export latex
If our ``gene'' is at least one nucleotide long, we add it to the
appropriate slice of genes for its chromosome. If the gene is the
first on its chromosome, we allocate the slice before storing the
gene in it.
#+end_export
#+begin_src go <<Add gene to slice, Chr.~\ref{ch:an}>>=
  if gene.end - gene.start >= 0 {
	  if genes[chr] == nil {
		  genes[chr] = make([]*interval, 0)
	  }
	  genes[chr] = append(genes[chr], gene)
  }
#+end_src
#+begin_src latex
  Now we can sort the genes per chromosome by casting them to
  \ty{ivSlice}.
#+end_src
#+begin_src go <<Sort genes, Ch.~\ref{ch:an}>>=
  for _, v := range genes {
	  is := ivSlice(v)
	  sort.Sort(is)
  }
#+end_src
#+begin_src latex
  We import \ty{sort}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "sort"
#+end_src
#+begin_src latex
  A row in the output table either ends in symbols or in IDs. We
  construct the header accordingly.
#+end_src
#+begin_src go <<Construct header, Ch.~\ref{ch:an}>>=
  header := "#Chr\tStart\tEnd\t"
  if *optS {
	  header += "Sym...\n"
  } else {
	  header += "ID...\n"
  }
#+end_src
#+begin_src latex
  Inside scan, we retrieve the arguments just passed, print a header for
  the new annotations unless the output is single column, and iterate
  over the intervals. At the end of each file, we flush the writer.
#+end_src
#+begin_src go <<Functions, Ch.~\ref{ch:an}>>=
  func scan(r io.Reader, args ...interface{}) {
	  //<<Retrieve arguments, Ch.~\ref{ch:an}>>
	  sc := bufio.NewScanner(r)
	  gm := make(map[string]bool)
	  if !col { fmt.Fprint(w, header) }
	  for sc.Scan() {
		  //<<Scan interval, Ch.~\ref{ch:an}>>
	  }
	  w.Flush()
  }
#+end_src
#+begin_src latex
  We import \ty{io}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "io"
#+end_src
#+begin_src latex
  We retrieve the arguments passed to \ty{scan} using type assertion.
#+end_src
#+begin_src go <<Retrieve arguments, Ch.~\ref{ch:an}>>=
  genes := args[0].(map[string][]*interval)
  w := args[1].(*bufio.Writer)
  header := args[2].(string)
  col := args[3].(bool)
#+end_src
#+begin_src latex
  While scanning intervals, a new set of intervals might start, marked
  by an empty line. In that case, we write a new header, unless we are
  asked to print the annotations in a single column, in which case we
  print a blank. Each interval is then intersected with the genes.
#+end_src
#+begin_src go <<Scan interval, Ch.~\ref{ch:an}>>=
  if len(sc.Text()) == 0 {
	  if col {
		  fmt.Fprint(w, "\n")
	  } else {
		  fmt.Fprint(w, header)
	  }
	  continue
  }
  //<<Extract interval, Ch.~\ref{ch:an}>>
  //<<Intersect interval with genes, Ch.~\ref{ch:an}>>
#+end_src
#+begin_src latex
  The interval consists of a chromosome, a start, and an end. We extract
  these values from the line.
#+end_src
#+begin_src go <<Extract interval, Ch.~\ref{ch:an}>>=
  fields := strings.Fields(sc.Text())
  chr := fields[0]
  s, err := strconv.Atoi(fields[1])
  if err != nil { log.Fatal(err.Error()) }
  e, err := strconv.Atoi(fields[2])
  if err != nil { log.Fatal(err.Error()) }
#+end_src
#+begin_src latex
  We reset the gene map, iterate over the genes that might intersect our
  interval, and collect their IDs. If any IDs were collected, we print
  the now annotated interval.
#+end_src
#+begin_src go <<Intersect interval with genes, Ch.~\ref{ch:an}>>=
  g := genes[chr]
  n := len(g)
  gid := ""
  //<<Reset gene map, Ch.~\ref{ch:an}>>
  //<<Collect accessions, Ch.~\ref{ch:an}>>
  if gid != "" {
	  //<<Print annotated interval, Ch.~\ref{ch:an}>>
  }
#+end_src
#+begin_src latex
  We reset the gene map by deleting its entries.
#+end_src
#+begin_src go <<Reset gene map, Ch.~\ref{ch:an}>>=
  for k, _ := range gm {
	  delete(gm, k)
  }
#+end_src
#+begin_src latex
  To look up the intersecting genes, we start from the leftmost gene
  that intersects the focus interval, $g_2$ in Figure~\ref{fig:iv}. From
  there we walk to the right.

#+end_src
#+begin_src go <<Collect accessions, Ch.~\ref{ch:an}>>=
  i := sort.Search(n, func(i int) bool {
	  return g[i].end >= s
  })
  //<<Walk right in gene array, Ch.~\ref{ch:an}>>
#+end_src
#+begin_src latex
  We walk to the right along the gene array until we reach the first
  gene whose start is to the right of the interval end, $g_6$ in
  Figure~\ref{fig:iv}.
#+end_src
#+begin_src go <<Walk right in gene array, Ch.~\ref{ch:an}>>=
  for i < len(g) && g[i].start <= e {
	  if !gm[g[i].id] {
		  //<<Add ID, Ch.~\ref{ch:an}>>
	  }
	  i++
  }
#+end_src
#+begin_src latex
  We add the gene ID to the gene map and to the ID string. The first
  entry in the string is separated by a tab, all subsequent ones by a
  comma.
#+end_src
#+begin_src go <<Add ID, Ch.~\ref{ch:an}>>=
  gm[g[i].id] = true
  if gid == "" {
	  gid += ("\t" + g[i].id)
  } else {
	  gid += ("," + g[i].id)
  }
#+end_src
#+begin_src latex
  We print the annotated interval to the tab writer. If \ty{-c} was set,
  we just print a single column.
#+end_src
#+begin_src go <<Print annotated interval, Ch.~\ref{ch:an}>>=
  if col {
	  fields := strings.Split(gid, ",")
	  for _, f := range fields {
		  if f[0] == '\t' { f = f[1:] }
		  fmt.Fprintf(w, "%s\n", f)
	  }
  } else {
	  fmt.Fprintf(w, "%s\t%d\t%d%s\n", chr, s, e, gid)
  }
#+end_src
#+begin_src latex
  We import \ty{fmt}.
#+end_src
#+begin_src go <<Imports, Ch.~\ref{ch:an}>>=
  "fmt"
#+end_src
#+begin_src latex
  We've finished writing \ty{annotate}, so let's test it.
  \section*{Testing}
  The outline of our testing program has hooks for imports and the
  testing logic.
#+end_src
#+begin_src go <<annotate_test.go>>=
  package main

  import (
	  "testing"
	  //<<Testing imports, Ch.~\ref{ch:an}>>
  )

  func TestAnnotate(t *testing.T) {
	  //<<Testing, Ch.~\ref{ch:an}>>
  }
#+end_src
#+begin_src latex
  We construct the tests and then iterate over them.
#+end_src
#+begin_src go <<Testing, Ch.~\ref{ch:an}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Ch.~\ref{ch:an}>>
  for i, test := range tests {
	  //<<Run test, Ch.~\ref{ch:an}>>
  }
#+end_src
#+begin_src latex
  We import \ty{exec}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:an}>>=
  "os/exec"
#+end_src
#+begin_export latex
Our tests run on the toy data illustrated in Figure~\ref{fig:iv}. So
we set the input data files for the toy data. Then we test the options
for transcripts and promoters, followed by tests of various promoter
lengths.
#+end_export
#+begin_src go <<Tests on toy data, Ch.~\ref{ch:an}>>=
    g := "../data/toy.gff"
    i := "../data/toyIv.txt"
    //<<Test transcripts and promoters, Ch.~\ref{ch:an}>>
    //<<Test promoter lengths, Ch.~\ref{ch:an}>>
#+end_src
#+begin_export latex
We write four tests for the promoter and transcript options. The first
test runs with all options on default, the second with symbols as
output, the third with transcripts as input, and the fourth with the
output in a single column.
#+end_export
#+begin_src go <<Test transcripts and promoters, Ch.~\ref{ch:an}>>=
  test := exec.Command("./annotate", g, i)
  tests = append(tests, test)
  test = exec.Command("./annotate", "-s", g, i)
  tests = append(tests, test)
  test = exec.Command("./annotate", "-t", g, i)
  tests = append(tests, test)
  test = exec.Command("./annotate", "-c", g, i)
  tests = append(tests, test)
#+end_src
#+begin_export latex
We write four tests with promoter lengths ranging from zero to 3.
#+end_export
#+begin_src go <<Test promoter lengths, Ch.~\ref{ch:an}>>=
  test = exec.Command("./annotate", "-l", "0", g, i)
  tests = append(tests, test)
  test = exec.Command("./annotate", "-l", "1", g, i)
  tests = append(tests, test)
  test = exec.Command("./annotate", "-l", "2", g, i)
  tests = append(tests, test)
  test = exec.Command("./annotate", "-l", "3", g, i)
  tests = append(tests, test)
#+end_src
#+begin_src latex
  When running a test, we compare what we get with what we want, which
  is stored in files \ty{r1.txt}, \ty{r2.txt},..., \ty{r8.txt}.
#+end_src
#+begin_src go <<Run test, Ch.~\ref{ch:an}>>=
  get, err := test.Output()
  if err != nil {
	  t.Error(err.Error())
  }
  f := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := ioutil.ReadFile(f)
  if err != nil {
	  t.Errorf("can't read %q", f)
  }
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s", get, want)
  }
#+end_src
#+begin_src latex
  We import \ty{strconv}, \ty{ioutil}, and \ty{bytes}.
#+end_src
#+begin_src go <<Testing imports, Ch.~\ref{ch:an}>>=
  "strconv"
  "io/ioutil"
  "bytes"
#+end_src
